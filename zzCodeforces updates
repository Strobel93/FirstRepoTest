################################################################
# 20 A: BerOS file system
# Input:
    # filepath with N forward slahes /
# Output:
    # remove dupliacte forward strings
################################################################
# Input:
file_path = '//usr///local//nginx/sbin'

# Output:
# V1:
recreation = [x for x, y in zip(file_path, file_path[1:]+'/') if x != y]
recreation = ''.join(recreation)

# V2:
new = ' '
for x in file_path:
    if new[-1] != x:
        new += x
new = new[1:]

# print(recreation)
# print(new)
################################################################
# 20 B: Equation Ax^2 + Bx + C = 0
# Input:
    # A, B, C values
# Output:
    # possible x values
################################################################
import math
# Input: 2,3
a, b, c = 1, -5, 6

# Output:
# Midnight Formula
def midnight(a: int, b: int, c: int):
    """Midnight Forumlar application"""
    x = ((-1 * b) + math.sqrt((b**2) - 4 * a * c)) / (2 * a)
    y = ((-1 * b) - math.sqrt((b**2) - 4 * a * c)) / (2 * a)
    print(x, y)


# midnight(a, b, c)

################################################################
# 20 C: Dijkstra
# Input:
    # Points: Start + End + Weight
# Output:
    # Shortest path from 1 to Last
################################################################
# Input: 1, 4, 3, 5
dots = [
          [1, 2, 2]
        , [2, 5, 5]
        , [2, 3, 4]
        , [1, 4, 1]
        , [4, 3, 3]
        , [3, 5, 1]
        ]

# Simple recursion reaching the end
path = []

def recur_simple(current, end, path_walked, previous_step):
    # Base Case: current = end
    if current == end:
        return path_walked

    # go to the next level
    else:
        # Add start of first execution
        if current not in path_walked:
            path_walked.append(current)

        # Get all available paths, sort by lowest weight and this and exclude previous step
        current_paths = [x for x in dots if x[0] == current and x[1] != previous_step]
        current_paths.sort(key=lambda x: x[2])
        path_walked.append(current_paths[0][1])
        new_current = current_paths[0][1]
        return recur_simple(new_current, end, path_walked, current)
# Test
# solution = recur_simple(1, 5, path, 1)
# print(solution)




# Dijkstar:
    # intialise all points distinance to infinity
    # go to closest unvisited point to start
    # weigh all points connected to current closest unvisited with total weight
    # add to current point to visited list
    # reevalue closest unvisited point to start (back to step 2)
# Point, Weight (initial infite), visited flag
history = [[i+1, 999, False] for i in range(5)]


def recur_dijkstra(current, tracker):
    current_index = current - 1
    unvisited = [x for x in tracker if x[2] is False]

    # Base Case: all points visited
    if not unvisited:
        return tracker

    # go to the next level
    else:
        # first iteration, set weight 0 since its the begin
        if len(unvisited) == len(tracker):
            tracker[current_index][1] = 0

        # Get all available paths from current value
        current_paths = [x for x in dots if x[0] == current]

        # For all available connections, update their total weight if it is less than current
        # Total weight = weight to current position + weight to visit
        for visit in current_paths:
            if tracker[visit[1]-1][1] > tracker[current_index][1] + visit[2]:
                # update weight on index
                tracker[visit[1]-1][1] = tracker[current_index][1] + visit[2]


        # Visited Flag for current position
        tracker[current_index][2] = True

        # Restart Recursion with Point of the lowest weight that has not been visited yet
        unvisited.sort(key=lambda x: x[1])
        new_current = unvisited[0][0]

        return recur_dijkstra(new_current, tracker)


result = recur_dijkstra(1, history)
start = [x for x in result if x[1] == 0]
print('Start', start[0][0])
for x in result:
    print('Point:                 ', x[0])
    print('min Distance to start: ', x[1])
    print('')



