import re
################################################################
# 21 A:
# Input:
    # String
# Output:
    # Legit Mail?
    # 16Chars_name@12host_name.domain
################################################################
# Input
string_check = '16Chars_name@12host_name.domain'

# Get Index of separators: @ and .
at_index = string_check.index('@')
dot_index = string_check.index('.')

# Create substrings that need to be checked for content
sub_at_string = string_check[:at_index]
sub_dot_string = string_check[at_index + 1:dot_index]
sub_dom_string = string_check[dot_index + 1:]
all_subs = [sub_dom_string, sub_dot_string, sub_dom_string]

# Check if in between these separators there are only legit values
# for sub in all_subs:
#     if re.fullmatch('[A-Za-z0-9_]+', sub):
#         print(sub, ' is valid')
#     else:
#         print(sub, ' not')
#
# # check all in one go
# if re.fullmatch('[A-Za-z0-9_]+@[A-Za-z0-9_]+.[A-Za-z0-9_]+', string_check):
#     print(string_check, ' is valid')
# else:
#     print(string_check, ' not')

################################################################
# 21 B:
# Input:
    # 2x straights equations (Ax+b)
# Output:
    # do they have an intersection
################################################################
# Input
straight_1 = [5, 2]
straight_2 = [1, 3]

# Output
# Calculate x by solving equation of s1 = s2
x = straight_1[0]-straight_2[0]
b = (straight_2[1]-straight_1[1]) / x
x = 1

# print(straight_1[0]*b + straight_1[1])
# print(straight_2[0]*b + straight_2[1])


################################################################
# 21 C: Stripe 2
# Input:
    # n Integers positive/negative
# Output:
    # amount of ways to seperate them in sets of 3 with equal value
################################################################
# Input: [1+2, 3, 3]
int_set = [1, 2, 3, 3]

# Output:
# Get all possible combinations of seperator indexes and check for each if all sums are equal
index_list = []
# for every Index
for x, _ in enumerate(int_set):
    # check every possible other position
    # on at least index + 1
    # not index beyond length
    for y, _ in enumerate(int_set):
        if y + 1 < len(int_set) and x != y + 1:
            # Position duplicates --> 1 3 == 3 1 --> prevent
            ordered = sorted([x, y + 1])
            # no duplicates and no leading zeros
            if ordered[0] != 0 and ordered not in index_list:
                index_list.append(ordered)

# for x in index_list:
#     print(x, int_set)
#     print(sum(int_set[:x[0]]))
#     print(sum(int_set[x[0]:x[1]]))
#     print(sum(int_set[x[1]:]))
#     print('')


def recur_test(input_list, current_index=1, current_index2 = 2, indexes_list=[]):
    # Base Case: current index is at last position, no more valid results
    if current_index + 1 == len(input_list):
        return indexes_list
    # trigger recursion with moving indexes
    else:
        # Add current Entry
        indexes_list.append([current_index, current_index2])

        # Change index depending on current indexes
        # Move secondary index +1
        if current_index2 + 1 != len(input_list):
            current_index2 += 1

        # Reset secondary index and move primary + 1
        else:
            current_index += 1
            current_index2 = current_index + 1

        return recur_test(input_list, current_index, current_index2, indexes_list)


recur_test_result = recur_test(int_set)
# print('Recur')
# for x in recur_test_result:
#     print(x, int_set)
#     print(sum(int_set[:x[0]]))
#     print(sum(int_set[x[0]:x[1]]))
#     print(sum(int_set[x[1]:]))
#     print('')
